// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Alert alert
//
// swagger:model Alert
type Alert struct {

	// Alert Details (according to alert type)
	// Read Only: true
	// Min Length: 1
	AlertDetails string `json:"details"`

	// Alert ID
	// Read Only: true
	// Min Length: 1
	AlertID string `json:"alertid"`

	// Alert Severity
	// Read Only: true
	// Min Length: 1
	// Enum: [Info Warning Critical Fatal]
	AlertSeverity string `json:"severity"`

	// Alert State
	// Read Only: true
	// Min Length: 1
	// Enum: [Active Acknowledged Cleared]
	AlertState string `json:"state"`

	// Alert Type
	// Read Only: true
	// Min Length: 1
	// Enum: [StateChange ProcessFailed ThresholdReached]
	AlertType string `json:"type"`

	// Alert Clear Time
	// Read Only: true
	// Min Length: 1
	ClearTime string `json:"cleartime"`

	// Alert Creation Time
	// Read Only: true
	// Min Length: 1
	CreationTime string `json:"creationtime"`

	// Alert Last Send Time
	// Read Only: true
	// Min Length: 1
	LastSendTime string `json:"lastsendtime"`

	// Alert Underlying Object ID
	// Read Only: true
	// Min Length: 1
	UnderlyingObjectID string `json:"objectid"`

	// Alert Underlying Object Type
	// Read Only: true
	// Min Length: 1
	// Enum: [Media Node Volume Snapshot Attachment]
	UnderlyingObjectType string `json:"objecttype"`
}

// Validate validates this alert
func (m *Alert) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAlertDetails(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlertType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClearTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreationTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastSendTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnderlyingObjectID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnderlyingObjectType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) validateAlertDetails(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertDetails) { // not required
		return nil
	}

	if err := validate.MinLength("details", "body", m.AlertDetails, 1); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateAlertID(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertID) { // not required
		return nil
	}

	if err := validate.MinLength("alertid", "body", m.AlertID, 1); err != nil {
		return err
	}

	return nil
}

var alertTypeAlertSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Info","Warning","Critical","Fatal"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertSeverityPropEnum = append(alertTypeAlertSeverityPropEnum, v)
	}
}

const (

	// AlertAlertSeverityInfo captures enum value "Info"
	AlertAlertSeverityInfo string = "Info"

	// AlertAlertSeverityWarning captures enum value "Warning"
	AlertAlertSeverityWarning string = "Warning"

	// AlertAlertSeverityCritical captures enum value "Critical"
	AlertAlertSeverityCritical string = "Critical"

	// AlertAlertSeverityFatal captures enum value "Fatal"
	AlertAlertSeverityFatal string = "Fatal"
)

// prop value enum
func (m *Alert) validateAlertSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertSeverity) { // not required
		return nil
	}

	if err := validate.MinLength("severity", "body", m.AlertSeverity, 1); err != nil {
		return err
	}

	// value enum
	if err := m.validateAlertSeverityEnum("severity", "body", m.AlertSeverity); err != nil {
		return err
	}

	return nil
}

var alertTypeAlertStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Active","Acknowledged","Cleared"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertStatePropEnum = append(alertTypeAlertStatePropEnum, v)
	}
}

const (

	// AlertAlertStateActive captures enum value "Active"
	AlertAlertStateActive string = "Active"

	// AlertAlertStateAcknowledged captures enum value "Acknowledged"
	AlertAlertStateAcknowledged string = "Acknowledged"

	// AlertAlertStateCleared captures enum value "Cleared"
	AlertAlertStateCleared string = "Cleared"
)

// prop value enum
func (m *Alert) validateAlertStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertState(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertState) { // not required
		return nil
	}

	if err := validate.MinLength("state", "body", m.AlertState, 1); err != nil {
		return err
	}

	// value enum
	if err := m.validateAlertStateEnum("state", "body", m.AlertState); err != nil {
		return err
	}

	return nil
}

var alertTypeAlertTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["StateChange","ProcessFailed","ThresholdReached"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeAlertTypePropEnum = append(alertTypeAlertTypePropEnum, v)
	}
}

const (

	// AlertAlertTypeStateChange captures enum value "StateChange"
	AlertAlertTypeStateChange string = "StateChange"

	// AlertAlertTypeProcessFailed captures enum value "ProcessFailed"
	AlertAlertTypeProcessFailed string = "ProcessFailed"

	// AlertAlertTypeThresholdReached captures enum value "ThresholdReached"
	AlertAlertTypeThresholdReached string = "ThresholdReached"
)

// prop value enum
func (m *Alert) validateAlertTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeAlertTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateAlertType(formats strfmt.Registry) error {
	if swag.IsZero(m.AlertType) { // not required
		return nil
	}

	if err := validate.MinLength("type", "body", m.AlertType, 1); err != nil {
		return err
	}

	// value enum
	if err := m.validateAlertTypeEnum("type", "body", m.AlertType); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateClearTime(formats strfmt.Registry) error {
	if swag.IsZero(m.ClearTime) { // not required
		return nil
	}

	if err := validate.MinLength("cleartime", "body", m.ClearTime, 1); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateCreationTime(formats strfmt.Registry) error {
	if swag.IsZero(m.CreationTime) { // not required
		return nil
	}

	if err := validate.MinLength("creationtime", "body", m.CreationTime, 1); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateLastSendTime(formats strfmt.Registry) error {
	if swag.IsZero(m.LastSendTime) { // not required
		return nil
	}

	if err := validate.MinLength("lastsendtime", "body", m.LastSendTime, 1); err != nil {
		return err
	}

	return nil
}

func (m *Alert) validateUnderlyingObjectID(formats strfmt.Registry) error {
	if swag.IsZero(m.UnderlyingObjectID) { // not required
		return nil
	}

	if err := validate.MinLength("objectid", "body", m.UnderlyingObjectID, 1); err != nil {
		return err
	}

	return nil
}

var alertTypeUnderlyingObjectTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Media","Node","Volume","Snapshot","Attachment"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		alertTypeUnderlyingObjectTypePropEnum = append(alertTypeUnderlyingObjectTypePropEnum, v)
	}
}

const (

	// AlertUnderlyingObjectTypeMedia captures enum value "Media"
	AlertUnderlyingObjectTypeMedia string = "Media"

	// AlertUnderlyingObjectTypeNode captures enum value "Node"
	AlertUnderlyingObjectTypeNode string = "Node"

	// AlertUnderlyingObjectTypeVolume captures enum value "Volume"
	AlertUnderlyingObjectTypeVolume string = "Volume"

	// AlertUnderlyingObjectTypeSnapshot captures enum value "Snapshot"
	AlertUnderlyingObjectTypeSnapshot string = "Snapshot"

	// AlertUnderlyingObjectTypeAttachment captures enum value "Attachment"
	AlertUnderlyingObjectTypeAttachment string = "Attachment"
)

// prop value enum
func (m *Alert) validateUnderlyingObjectTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, alertTypeUnderlyingObjectTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Alert) validateUnderlyingObjectType(formats strfmt.Registry) error {
	if swag.IsZero(m.UnderlyingObjectType) { // not required
		return nil
	}

	if err := validate.MinLength("objecttype", "body", m.UnderlyingObjectType, 1); err != nil {
		return err
	}

	// value enum
	if err := m.validateUnderlyingObjectTypeEnum("objecttype", "body", m.UnderlyingObjectType); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this alert based on the context it is used
func (m *Alert) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAlertDetails(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertSeverity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertState(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAlertType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClearTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCreationTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastSendTime(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnderlyingObjectID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUnderlyingObjectType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Alert) contextValidateAlertDetails(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "details", "body", string(m.AlertDetails)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "alertid", "body", string(m.AlertID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertSeverity(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "severity", "body", string(m.AlertSeverity)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertState(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "state", "body", string(m.AlertState)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateAlertType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "type", "body", string(m.AlertType)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateClearTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "cleartime", "body", string(m.ClearTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateCreationTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "creationtime", "body", string(m.CreationTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateLastSendTime(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "lastsendtime", "body", string(m.LastSendTime)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUnderlyingObjectID(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "objectid", "body", string(m.UnderlyingObjectID)); err != nil {
		return err
	}

	return nil
}

func (m *Alert) contextValidateUnderlyingObjectType(ctx context.Context, formats strfmt.Registry) error {

	if err := validate.ReadOnly(ctx, "objecttype", "body", string(m.UnderlyingObjectType)); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Alert) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Alert) UnmarshalBinary(b []byte) error {
	var res Alert
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
